// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/authentication/authentication.proto

#ifndef PROTOBUF_service_2fauthentication_2fauthentication_2eproto__INCLUDED
#define PROTOBUF_service_2fauthentication_2fauthentication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
#include "lib/rpc/rpc.pb.h"
#include "lib/protocol/content_handle.pb.h"
#include "lib/protocol/entity.pb.h"
#include "lib/config/process_config.pb.h"
// @@protoc_insertion_point(includes)

namespace bnet {
namespace protocol {
namespace authentication {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();

class ModuleLoadRequest;
class ModuleLoadResponse;
class ModuleMessageRequest;
class LogonRequest;
class LogonResponse;
class AuthenticationConfig;
class AuthModuleVariant;
class AuthModuleConfig;
class AuthAgreementLocale;
class AuthAgreement;

// ===================================================================

class ModuleLoadRequest : public ::google::protobuf::Message {
 public:
  ModuleLoadRequest();
  virtual ~ModuleLoadRequest();
  
  ModuleLoadRequest(const ModuleLoadRequest& from);
  
  inline ModuleLoadRequest& operator=(const ModuleLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleLoadRequest& default_instance();
  
  void Swap(ModuleLoadRequest* other);
  
  // implements Message ----------------------------------------------
  
  ModuleLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleLoadRequest& from);
  void MergeFrom(const ModuleLoadRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.ContentHandle module_handle = 1;
  inline bool has_module_handle() const;
  inline void clear_module_handle();
  static const int kModuleHandleFieldNumber = 1;
  inline const ::bnet::protocol::ContentHandle& module_handle() const;
  inline ::bnet::protocol::ContentHandle* mutable_module_handle();
  
  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.ModuleLoadRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bnet::protocol::ContentHandle* module_handle_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModuleLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModuleLoadResponse : public ::google::protobuf::Message {
 public:
  ModuleLoadResponse();
  virtual ~ModuleLoadResponse();
  
  ModuleLoadResponse(const ModuleLoadResponse& from);
  
  inline ModuleLoadResponse& operator=(const ModuleLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleLoadResponse& default_instance();
  
  void Swap(ModuleLoadResponse* other);
  
  // implements Message ----------------------------------------------
  
  ModuleLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleLoadResponse& from);
  void MergeFrom(const ModuleLoadResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 module_id = 2;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 2;
  inline ::google::protobuf::int32 module_id() const;
  inline void set_module_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.ModuleLoadResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 module_id_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModuleLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModuleMessageRequest : public ::google::protobuf::Message {
 public:
  ModuleMessageRequest();
  virtual ~ModuleMessageRequest();
  
  ModuleMessageRequest(const ModuleMessageRequest& from);
  
  inline ModuleMessageRequest& operator=(const ModuleMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleMessageRequest& default_instance();
  
  void Swap(ModuleMessageRequest* other);
  
  // implements Message ----------------------------------------------
  
  ModuleMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleMessageRequest& from);
  void MergeFrom(const ModuleMessageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 module_id = 1;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 1;
  inline ::google::protobuf::int32 module_id() const;
  inline void set_module_id(::google::protobuf::int32 value);
  
  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.ModuleMessageRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 module_id_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModuleMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogonRequest : public ::google::protobuf::Message {
 public:
  LogonRequest();
  virtual ~LogonRequest();
  
  LogonRequest(const LogonRequest& from);
  
  inline LogonRequest& operator=(const LogonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonRequest& default_instance();
  
  void Swap(LogonRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogonRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogonRequest& from);
  void MergeFrom(const LogonRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string program = 1;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 1;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const char* value, size_t size);
  inline ::std::string* mutable_program();
  
  // optional string platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  
  // optional string locale = 3;
  inline bool has_locale() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 3;
  inline const ::std::string& locale() const;
  inline void set_locale(const ::std::string& value);
  inline void set_locale(const char* value);
  inline void set_locale(const char* value, size_t size);
  inline ::std::string* mutable_locale();
  
  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  
  // optional uint64 listener_id = 5;
  inline bool has_listener_id() const;
  inline void clear_listener_id();
  static const int kListenerIdFieldNumber = 5;
  inline ::google::protobuf::uint64 listener_id() const;
  inline void set_listener_id(::google::protobuf::uint64 value);
  
  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.LogonRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* program_;
  static const ::std::string _default_program_;
  ::std::string* platform_;
  static const ::std::string _default_platform_;
  ::std::string* locale_;
  static const ::std::string _default_locale_;
  ::std::string* email_;
  static const ::std::string _default_email_;
  ::google::protobuf::uint64 listener_id_;
  ::std::string* version_;
  static const ::std::string _default_version_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LogonRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogonResponse : public ::google::protobuf::Message {
 public:
  LogonResponse();
  virtual ~LogonResponse();
  
  LogonResponse(const LogonResponse& from);
  
  inline LogonResponse& operator=(const LogonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonResponse& default_instance();
  
  void Swap(LogonResponse* other);
  
  // implements Message ----------------------------------------------
  
  LogonResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogonResponse& from);
  void MergeFrom(const LogonResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .bnet.protocol.EntityId account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::bnet::protocol::EntityId& account() const;
  inline ::bnet::protocol::EntityId* mutable_account();
  
  // required .bnet.protocol.EntityId game_account = 2;
  inline bool has_game_account() const;
  inline void clear_game_account();
  static const int kGameAccountFieldNumber = 2;
  inline const ::bnet::protocol::EntityId& game_account() const;
  inline ::bnet::protocol::EntityId* mutable_game_account();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.LogonResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::bnet::protocol::EntityId* account_;
  ::bnet::protocol::EntityId* game_account_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LogonResponse* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationConfig : public ::google::protobuf::Message {
 public:
  AuthenticationConfig();
  virtual ~AuthenticationConfig();
  
  AuthenticationConfig(const AuthenticationConfig& from);
  
  inline AuthenticationConfig& operator=(const AuthenticationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticationConfig& default_instance();
  
  void Swap(AuthenticationConfig* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticationConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticationConfig& from);
  void MergeFrom(const AuthenticationConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .bnet.protocol.config.Resource module = 1;
  inline int module_size() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::bnet::protocol::config::Resource& module(int index) const;
  inline ::bnet::protocol::config::Resource* mutable_module(int index);
  inline ::bnet::protocol::config::Resource* add_module();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >&
      module() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >*
      mutable_module();
  
  // repeated string allow_version = 2;
  inline int allow_version_size() const;
  inline void clear_allow_version();
  static const int kAllowVersionFieldNumber = 2;
  inline const ::std::string& allow_version(int index) const;
  inline ::std::string* mutable_allow_version(int index);
  inline void set_allow_version(int index, const ::std::string& value);
  inline void set_allow_version(int index, const char* value);
  inline void set_allow_version(int index, const char* value, size_t size);
  inline ::std::string* add_allow_version();
  inline void add_allow_version(const ::std::string& value);
  inline void add_allow_version(const char* value);
  inline void add_allow_version(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& allow_version() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allow_version();
  
  // repeated string deny_version = 3;
  inline int deny_version_size() const;
  inline void clear_deny_version();
  static const int kDenyVersionFieldNumber = 3;
  inline const ::std::string& deny_version(int index) const;
  inline ::std::string* mutable_deny_version(int index);
  inline void set_deny_version(int index, const ::std::string& value);
  inline void set_deny_version(int index, const char* value);
  inline void set_deny_version(int index, const char* value, size_t size);
  inline ::std::string* add_deny_version();
  inline void add_deny_version(const ::std::string& value);
  inline void add_deny_version(const char* value);
  inline void add_deny_version(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& deny_version() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_deny_version();
  
  // repeated .bnet.protocol.config.Resource agreement = 4;
  inline int agreement_size() const;
  inline void clear_agreement();
  static const int kAgreementFieldNumber = 4;
  inline const ::bnet::protocol::config::Resource& agreement(int index) const;
  inline ::bnet::protocol::config::Resource* mutable_agreement(int index);
  inline ::bnet::protocol::config::Resource* add_agreement();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >&
      agreement() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >*
      mutable_agreement();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.AuthenticationConfig)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource > module_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allow_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> deny_version_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource > agreement_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthenticationConfig* default_instance_;
};
// -------------------------------------------------------------------

class AuthModuleVariant : public ::google::protobuf::Message {
 public:
  AuthModuleVariant();
  virtual ~AuthModuleVariant();
  
  AuthModuleVariant(const AuthModuleVariant& from);
  
  inline AuthModuleVariant& operator=(const AuthModuleVariant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthModuleVariant& default_instance();
  
  void Swap(AuthModuleVariant* other);
  
  // implements Message ----------------------------------------------
  
  AuthModuleVariant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthModuleVariant& from);
  void MergeFrom(const AuthModuleVariant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  
  // required string handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline const ::std::string& handle() const;
  inline void set_handle(const ::std::string& value);
  inline void set_handle(const char* value);
  inline void set_handle(const char* value, size_t size);
  inline ::std::string* mutable_handle();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.AuthModuleVariant)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* platform_;
  static const ::std::string _default_platform_;
  ::std::string* handle_;
  static const ::std::string _default_handle_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthModuleVariant* default_instance_;
};
// -------------------------------------------------------------------

class AuthModuleConfig : public ::google::protobuf::Message {
 public:
  AuthModuleConfig();
  virtual ~AuthModuleConfig();
  
  AuthModuleConfig(const AuthModuleConfig& from);
  
  inline AuthModuleConfig& operator=(const AuthModuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthModuleConfig& default_instance();
  
  void Swap(AuthModuleConfig* other);
  
  // implements Message ----------------------------------------------
  
  AuthModuleConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthModuleConfig& from);
  void MergeFrom(const AuthModuleConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .bnet.protocol.authentication.AuthModuleVariant variant = 1;
  inline int variant_size() const;
  inline void clear_variant();
  static const int kVariantFieldNumber = 1;
  inline const ::bnet::protocol::authentication::AuthModuleVariant& variant(int index) const;
  inline ::bnet::protocol::authentication::AuthModuleVariant* mutable_variant(int index);
  inline ::bnet::protocol::authentication::AuthModuleVariant* add_variant();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthModuleVariant >&
      variant() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthModuleVariant >*
      mutable_variant();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.AuthModuleConfig)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthModuleVariant > variant_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthModuleConfig* default_instance_;
};
// -------------------------------------------------------------------

class AuthAgreementLocale : public ::google::protobuf::Message {
 public:
  AuthAgreementLocale();
  virtual ~AuthAgreementLocale();
  
  AuthAgreementLocale(const AuthAgreementLocale& from);
  
  inline AuthAgreementLocale& operator=(const AuthAgreementLocale& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAgreementLocale& default_instance();
  
  void Swap(AuthAgreementLocale* other);
  
  // implements Message ----------------------------------------------
  
  AuthAgreementLocale* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthAgreementLocale& from);
  void MergeFrom(const AuthAgreementLocale& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required string handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline const ::std::string& handle() const;
  inline void set_handle(const ::std::string& value);
  inline void set_handle(const char* value);
  inline void set_handle(const char* value, size_t size);
  inline ::std::string* mutable_handle();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.AuthAgreementLocale)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* handle_;
  static const ::std::string _default_handle_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthAgreementLocale* default_instance_;
};
// -------------------------------------------------------------------

class AuthAgreement : public ::google::protobuf::Message {
 public:
  AuthAgreement();
  virtual ~AuthAgreement();
  
  AuthAgreement(const AuthAgreement& from);
  
  inline AuthAgreement& operator=(const AuthAgreement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthAgreement& default_instance();
  
  void Swap(AuthAgreement* other);
  
  // implements Message ----------------------------------------------
  
  AuthAgreement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthAgreement& from);
  void MergeFrom(const AuthAgreement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // required string program = 2;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 2;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const char* value, size_t size);
  inline ::std::string* mutable_program();
  
  // required uint32 scheme = 3;
  inline bool has_scheme() const;
  inline void clear_scheme();
  static const int kSchemeFieldNumber = 3;
  inline ::google::protobuf::uint32 scheme() const;
  inline void set_scheme(::google::protobuf::uint32 value);
  
  // repeated .bnet.protocol.authentication.AuthAgreementLocale locale = 4;
  inline int locale_size() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 4;
  inline const ::bnet::protocol::authentication::AuthAgreementLocale& locale(int index) const;
  inline ::bnet::protocol::authentication::AuthAgreementLocale* mutable_locale(int index);
  inline ::bnet::protocol::authentication::AuthAgreementLocale* add_locale();
  inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthAgreementLocale >&
      locale() const;
  inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthAgreementLocale >*
      mutable_locale();
  
  // @@protoc_insertion_point(class_scope:bnet.protocol.authentication.AuthAgreement)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::std::string* program_;
  static const ::std::string _default_program_;
  ::google::protobuf::uint32 scheme_;
  ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthAgreementLocale > locale_;
  friend void  protobuf_AddDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_AssignDesc_service_2fauthentication_2fauthentication_2eproto();
  friend void protobuf_ShutdownFile_service_2fauthentication_2fauthentication_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthAgreement* default_instance_;
};
// ===================================================================

class AuthenticationClient_Stub;

class AuthenticationClient : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline AuthenticationClient() {};
 public:
  virtual ~AuthenticationClient();
  
  typedef AuthenticationClient_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void ModuleLoad(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleLoadRequest* request,
                       ::bnet::protocol::authentication::ModuleLoadResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ModuleMessage(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleMessageRequest* request,
                       ::bnet::protocol::NoData* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationClient);
};

class AuthenticationClient_Stub : public AuthenticationClient {
 public:
  AuthenticationClient_Stub(::google::protobuf::RpcChannel* channel);
  AuthenticationClient_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~AuthenticationClient_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements AuthenticationClient ------------------------------------------
  
  void ModuleLoad(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleLoadRequest* request,
                       ::bnet::protocol::authentication::ModuleLoadResponse* response,
                       ::google::protobuf::Closure* done);
  void ModuleMessage(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleMessageRequest* request,
                       ::bnet::protocol::NoData* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationClient_Stub);
};


// -------------------------------------------------------------------

class AuthenticationServer_Stub;

class AuthenticationServer : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline AuthenticationServer() {};
 public:
  virtual ~AuthenticationServer();
  
  typedef AuthenticationServer_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Logon(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::LogonRequest* request,
                       ::bnet::protocol::authentication::LogonResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ModuleMessage(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleMessageRequest* request,
                       ::bnet::protocol::NoData* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationServer);
};

class AuthenticationServer_Stub : public AuthenticationServer {
 public:
  AuthenticationServer_Stub(::google::protobuf::RpcChannel* channel);
  AuthenticationServer_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~AuthenticationServer_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements AuthenticationServer ------------------------------------------
  
  void Logon(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::LogonRequest* request,
                       ::bnet::protocol::authentication::LogonResponse* response,
                       ::google::protobuf::Closure* done);
  void ModuleMessage(::google::protobuf::RpcController* controller,
                       const ::bnet::protocol::authentication::ModuleMessageRequest* request,
                       ::bnet::protocol::NoData* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationServer_Stub);
};


// ===================================================================


// ===================================================================

// ModuleLoadRequest

// required .bnet.protocol.ContentHandle module_handle = 1;
inline bool ModuleLoadRequest::has_module_handle() const {
  return _has_bit(0);
}
inline void ModuleLoadRequest::clear_module_handle() {
  if (module_handle_ != NULL) module_handle_->::bnet::protocol::ContentHandle::Clear();
  _clear_bit(0);
}
inline const ::bnet::protocol::ContentHandle& ModuleLoadRequest::module_handle() const {
  return module_handle_ != NULL ? *module_handle_ : *default_instance_->module_handle_;
}
inline ::bnet::protocol::ContentHandle* ModuleLoadRequest::mutable_module_handle() {
  _set_bit(0);
  if (module_handle_ == NULL) module_handle_ = new ::bnet::protocol::ContentHandle;
  return module_handle_;
}

// optional bytes message = 2;
inline bool ModuleLoadRequest::has_message() const {
  return _has_bit(1);
}
inline void ModuleLoadRequest::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ModuleLoadRequest::message() const {
  return *message_;
}
inline void ModuleLoadRequest::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ModuleLoadRequest::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ModuleLoadRequest::set_message(const void* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleLoadRequest::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// ModuleLoadResponse

// optional int32 module_id = 2;
inline bool ModuleLoadResponse::has_module_id() const {
  return _has_bit(0);
}
inline void ModuleLoadResponse::clear_module_id() {
  module_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ModuleLoadResponse::module_id() const {
  return module_id_;
}
inline void ModuleLoadResponse::set_module_id(::google::protobuf::int32 value) {
  _set_bit(0);
  module_id_ = value;
}

// -------------------------------------------------------------------

// ModuleMessageRequest

// required int32 module_id = 1;
inline bool ModuleMessageRequest::has_module_id() const {
  return _has_bit(0);
}
inline void ModuleMessageRequest::clear_module_id() {
  module_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ModuleMessageRequest::module_id() const {
  return module_id_;
}
inline void ModuleMessageRequest::set_module_id(::google::protobuf::int32 value) {
  _set_bit(0);
  module_id_ = value;
}

// optional bytes message = 2;
inline bool ModuleMessageRequest::has_message() const {
  return _has_bit(1);
}
inline void ModuleMessageRequest::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ModuleMessageRequest::message() const {
  return *message_;
}
inline void ModuleMessageRequest::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ModuleMessageRequest::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ModuleMessageRequest::set_message(const void* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleMessageRequest::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// LogonRequest

// optional string program = 1;
inline bool LogonRequest::has_program() const {
  return _has_bit(0);
}
inline void LogonRequest::clear_program() {
  if (program_ != &_default_program_) {
    program_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LogonRequest::program() const {
  return *program_;
}
inline void LogonRequest::set_program(const ::std::string& value) {
  _set_bit(0);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void LogonRequest::set_program(const char* value) {
  _set_bit(0);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void LogonRequest::set_program(const char* value, size_t size) {
  _set_bit(0);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_program() {
  _set_bit(0);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  return program_;
}

// optional string platform = 2;
inline bool LogonRequest::has_platform() const {
  return _has_bit(1);
}
inline void LogonRequest::clear_platform() {
  if (platform_ != &_default_platform_) {
    platform_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LogonRequest::platform() const {
  return *platform_;
}
inline void LogonRequest::set_platform(const ::std::string& value) {
  _set_bit(1);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void LogonRequest::set_platform(const char* value) {
  _set_bit(1);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void LogonRequest::set_platform(const char* value, size_t size) {
  _set_bit(1);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_platform() {
  _set_bit(1);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  return platform_;
}

// optional string locale = 3;
inline bool LogonRequest::has_locale() const {
  return _has_bit(2);
}
inline void LogonRequest::clear_locale() {
  if (locale_ != &_default_locale_) {
    locale_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LogonRequest::locale() const {
  return *locale_;
}
inline void LogonRequest::set_locale(const ::std::string& value) {
  _set_bit(2);
  if (locale_ == &_default_locale_) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void LogonRequest::set_locale(const char* value) {
  _set_bit(2);
  if (locale_ == &_default_locale_) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void LogonRequest::set_locale(const char* value, size_t size) {
  _set_bit(2);
  if (locale_ == &_default_locale_) {
    locale_ = new ::std::string;
  }
  locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_locale() {
  _set_bit(2);
  if (locale_ == &_default_locale_) {
    locale_ = new ::std::string;
  }
  return locale_;
}

// optional string email = 4;
inline bool LogonRequest::has_email() const {
  return _has_bit(3);
}
inline void LogonRequest::clear_email() {
  if (email_ != &_default_email_) {
    email_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& LogonRequest::email() const {
  return *email_;
}
inline void LogonRequest::set_email(const ::std::string& value) {
  _set_bit(3);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void LogonRequest::set_email(const char* value) {
  _set_bit(3);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void LogonRequest::set_email(const char* value, size_t size) {
  _set_bit(3);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_email() {
  _set_bit(3);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  return email_;
}

// optional uint64 listener_id = 5;
inline bool LogonRequest::has_listener_id() const {
  return _has_bit(4);
}
inline void LogonRequest::clear_listener_id() {
  listener_id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 LogonRequest::listener_id() const {
  return listener_id_;
}
inline void LogonRequest::set_listener_id(::google::protobuf::uint64 value) {
  _set_bit(4);
  listener_id_ = value;
}

// optional string version = 6;
inline bool LogonRequest::has_version() const {
  return _has_bit(5);
}
inline void LogonRequest::clear_version() {
  if (version_ != &_default_version_) {
    version_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& LogonRequest::version() const {
  return *version_;
}
inline void LogonRequest::set_version(const ::std::string& value) {
  _set_bit(5);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LogonRequest::set_version(const char* value) {
  _set_bit(5);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LogonRequest::set_version(const char* value, size_t size) {
  _set_bit(5);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogonRequest::mutable_version() {
  _set_bit(5);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  return version_;
}

// -------------------------------------------------------------------

// LogonResponse

// required .bnet.protocol.EntityId account = 1;
inline bool LogonResponse::has_account() const {
  return _has_bit(0);
}
inline void LogonResponse::clear_account() {
  if (account_ != NULL) account_->::bnet::protocol::EntityId::Clear();
  _clear_bit(0);
}
inline const ::bnet::protocol::EntityId& LogonResponse::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::bnet::protocol::EntityId* LogonResponse::mutable_account() {
  _set_bit(0);
  if (account_ == NULL) account_ = new ::bnet::protocol::EntityId;
  return account_;
}

// required .bnet.protocol.EntityId game_account = 2;
inline bool LogonResponse::has_game_account() const {
  return _has_bit(1);
}
inline void LogonResponse::clear_game_account() {
  if (game_account_ != NULL) game_account_->::bnet::protocol::EntityId::Clear();
  _clear_bit(1);
}
inline const ::bnet::protocol::EntityId& LogonResponse::game_account() const {
  return game_account_ != NULL ? *game_account_ : *default_instance_->game_account_;
}
inline ::bnet::protocol::EntityId* LogonResponse::mutable_game_account() {
  _set_bit(1);
  if (game_account_ == NULL) game_account_ = new ::bnet::protocol::EntityId;
  return game_account_;
}

// -------------------------------------------------------------------

// AuthenticationConfig

// repeated .bnet.protocol.config.Resource module = 1;
inline int AuthenticationConfig::module_size() const {
  return module_.size();
}
inline void AuthenticationConfig::clear_module() {
  module_.Clear();
}
inline const ::bnet::protocol::config::Resource& AuthenticationConfig::module(int index) const {
  return module_.Get(index);
}
inline ::bnet::protocol::config::Resource* AuthenticationConfig::mutable_module(int index) {
  return module_.Mutable(index);
}
inline ::bnet::protocol::config::Resource* AuthenticationConfig::add_module() {
  return module_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >&
AuthenticationConfig::module() const {
  return module_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >*
AuthenticationConfig::mutable_module() {
  return &module_;
}

// repeated string allow_version = 2;
inline int AuthenticationConfig::allow_version_size() const {
  return allow_version_.size();
}
inline void AuthenticationConfig::clear_allow_version() {
  allow_version_.Clear();
}
inline const ::std::string& AuthenticationConfig::allow_version(int index) const {
  return allow_version_.Get(index);
}
inline ::std::string* AuthenticationConfig::mutable_allow_version(int index) {
  return allow_version_.Mutable(index);
}
inline void AuthenticationConfig::set_allow_version(int index, const ::std::string& value) {
  allow_version_.Mutable(index)->assign(value);
}
inline void AuthenticationConfig::set_allow_version(int index, const char* value) {
  allow_version_.Mutable(index)->assign(value);
}
inline void AuthenticationConfig::set_allow_version(int index, const char* value, size_t size) {
  allow_version_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationConfig::add_allow_version() {
  return allow_version_.Add();
}
inline void AuthenticationConfig::add_allow_version(const ::std::string& value) {
  allow_version_.Add()->assign(value);
}
inline void AuthenticationConfig::add_allow_version(const char* value) {
  allow_version_.Add()->assign(value);
}
inline void AuthenticationConfig::add_allow_version(const char* value, size_t size) {
  allow_version_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AuthenticationConfig::allow_version() const {
  return allow_version_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AuthenticationConfig::mutable_allow_version() {
  return &allow_version_;
}

// repeated string deny_version = 3;
inline int AuthenticationConfig::deny_version_size() const {
  return deny_version_.size();
}
inline void AuthenticationConfig::clear_deny_version() {
  deny_version_.Clear();
}
inline const ::std::string& AuthenticationConfig::deny_version(int index) const {
  return deny_version_.Get(index);
}
inline ::std::string* AuthenticationConfig::mutable_deny_version(int index) {
  return deny_version_.Mutable(index);
}
inline void AuthenticationConfig::set_deny_version(int index, const ::std::string& value) {
  deny_version_.Mutable(index)->assign(value);
}
inline void AuthenticationConfig::set_deny_version(int index, const char* value) {
  deny_version_.Mutable(index)->assign(value);
}
inline void AuthenticationConfig::set_deny_version(int index, const char* value, size_t size) {
  deny_version_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationConfig::add_deny_version() {
  return deny_version_.Add();
}
inline void AuthenticationConfig::add_deny_version(const ::std::string& value) {
  deny_version_.Add()->assign(value);
}
inline void AuthenticationConfig::add_deny_version(const char* value) {
  deny_version_.Add()->assign(value);
}
inline void AuthenticationConfig::add_deny_version(const char* value, size_t size) {
  deny_version_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AuthenticationConfig::deny_version() const {
  return deny_version_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AuthenticationConfig::mutable_deny_version() {
  return &deny_version_;
}

// repeated .bnet.protocol.config.Resource agreement = 4;
inline int AuthenticationConfig::agreement_size() const {
  return agreement_.size();
}
inline void AuthenticationConfig::clear_agreement() {
  agreement_.Clear();
}
inline const ::bnet::protocol::config::Resource& AuthenticationConfig::agreement(int index) const {
  return agreement_.Get(index);
}
inline ::bnet::protocol::config::Resource* AuthenticationConfig::mutable_agreement(int index) {
  return agreement_.Mutable(index);
}
inline ::bnet::protocol::config::Resource* AuthenticationConfig::add_agreement() {
  return agreement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >&
AuthenticationConfig::agreement() const {
  return agreement_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::config::Resource >*
AuthenticationConfig::mutable_agreement() {
  return &agreement_;
}

// -------------------------------------------------------------------

// AuthModuleVariant

// required string platform = 1;
inline bool AuthModuleVariant::has_platform() const {
  return _has_bit(0);
}
inline void AuthModuleVariant::clear_platform() {
  if (platform_ != &_default_platform_) {
    platform_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AuthModuleVariant::platform() const {
  return *platform_;
}
inline void AuthModuleVariant::set_platform(const ::std::string& value) {
  _set_bit(0);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void AuthModuleVariant::set_platform(const char* value) {
  _set_bit(0);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void AuthModuleVariant::set_platform(const char* value, size_t size) {
  _set_bit(0);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthModuleVariant::mutable_platform() {
  _set_bit(0);
  if (platform_ == &_default_platform_) {
    platform_ = new ::std::string;
  }
  return platform_;
}

// required string handle = 2;
inline bool AuthModuleVariant::has_handle() const {
  return _has_bit(1);
}
inline void AuthModuleVariant::clear_handle() {
  if (handle_ != &_default_handle_) {
    handle_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AuthModuleVariant::handle() const {
  return *handle_;
}
inline void AuthModuleVariant::set_handle(const ::std::string& value) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(value);
}
inline void AuthModuleVariant::set_handle(const char* value) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(value);
}
inline void AuthModuleVariant::set_handle(const char* value, size_t size) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthModuleVariant::mutable_handle() {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  return handle_;
}

// -------------------------------------------------------------------

// AuthModuleConfig

// repeated .bnet.protocol.authentication.AuthModuleVariant variant = 1;
inline int AuthModuleConfig::variant_size() const {
  return variant_.size();
}
inline void AuthModuleConfig::clear_variant() {
  variant_.Clear();
}
inline const ::bnet::protocol::authentication::AuthModuleVariant& AuthModuleConfig::variant(int index) const {
  return variant_.Get(index);
}
inline ::bnet::protocol::authentication::AuthModuleVariant* AuthModuleConfig::mutable_variant(int index) {
  return variant_.Mutable(index);
}
inline ::bnet::protocol::authentication::AuthModuleVariant* AuthModuleConfig::add_variant() {
  return variant_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthModuleVariant >&
AuthModuleConfig::variant() const {
  return variant_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthModuleVariant >*
AuthModuleConfig::mutable_variant() {
  return &variant_;
}

// -------------------------------------------------------------------

// AuthAgreementLocale

// required string id = 1;
inline bool AuthAgreementLocale::has_id() const {
  return _has_bit(0);
}
inline void AuthAgreementLocale::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AuthAgreementLocale::id() const {
  return *id_;
}
inline void AuthAgreementLocale::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AuthAgreementLocale::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AuthAgreementLocale::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthAgreementLocale::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required string handle = 2;
inline bool AuthAgreementLocale::has_handle() const {
  return _has_bit(1);
}
inline void AuthAgreementLocale::clear_handle() {
  if (handle_ != &_default_handle_) {
    handle_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AuthAgreementLocale::handle() const {
  return *handle_;
}
inline void AuthAgreementLocale::set_handle(const ::std::string& value) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(value);
}
inline void AuthAgreementLocale::set_handle(const char* value) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(value);
}
inline void AuthAgreementLocale::set_handle(const char* value, size_t size) {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  handle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthAgreementLocale::mutable_handle() {
  _set_bit(1);
  if (handle_ == &_default_handle_) {
    handle_ = new ::std::string;
  }
  return handle_;
}

// -------------------------------------------------------------------

// AuthAgreement

// required string type = 1;
inline bool AuthAgreement::has_type() const {
  return _has_bit(0);
}
inline void AuthAgreement::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AuthAgreement::type() const {
  return *type_;
}
inline void AuthAgreement::set_type(const ::std::string& value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void AuthAgreement::set_type(const char* value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void AuthAgreement::set_type(const char* value, size_t size) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthAgreement::mutable_type() {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// required string program = 2;
inline bool AuthAgreement::has_program() const {
  return _has_bit(1);
}
inline void AuthAgreement::clear_program() {
  if (program_ != &_default_program_) {
    program_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AuthAgreement::program() const {
  return *program_;
}
inline void AuthAgreement::set_program(const ::std::string& value) {
  _set_bit(1);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void AuthAgreement::set_program(const char* value) {
  _set_bit(1);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void AuthAgreement::set_program(const char* value, size_t size) {
  _set_bit(1);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthAgreement::mutable_program() {
  _set_bit(1);
  if (program_ == &_default_program_) {
    program_ = new ::std::string;
  }
  return program_;
}

// required uint32 scheme = 3;
inline bool AuthAgreement::has_scheme() const {
  return _has_bit(2);
}
inline void AuthAgreement::clear_scheme() {
  scheme_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 AuthAgreement::scheme() const {
  return scheme_;
}
inline void AuthAgreement::set_scheme(::google::protobuf::uint32 value) {
  _set_bit(2);
  scheme_ = value;
}

// repeated .bnet.protocol.authentication.AuthAgreementLocale locale = 4;
inline int AuthAgreement::locale_size() const {
  return locale_.size();
}
inline void AuthAgreement::clear_locale() {
  locale_.Clear();
}
inline const ::bnet::protocol::authentication::AuthAgreementLocale& AuthAgreement::locale(int index) const {
  return locale_.Get(index);
}
inline ::bnet::protocol::authentication::AuthAgreementLocale* AuthAgreement::mutable_locale(int index) {
  return locale_.Mutable(index);
}
inline ::bnet::protocol::authentication::AuthAgreementLocale* AuthAgreement::add_locale() {
  return locale_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthAgreementLocale >&
AuthAgreement::locale() const {
  return locale_;
}
inline ::google::protobuf::RepeatedPtrField< ::bnet::protocol::authentication::AuthAgreementLocale >*
AuthAgreement::mutable_locale() {
  return &locale_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace authentication
}  // namespace protocol
}  // namespace bnet

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_2fauthentication_2fauthentication_2eproto__INCLUDED
